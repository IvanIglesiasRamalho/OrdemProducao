"""
tela_info_produto.py
Python 3.12+ | Postgres 16+ | Tkinter + psycopg2 (sem pool)

Estrutura (19 colunas):
  estoqueMinimo, estoqueMaximo, estoqueLocalizacao, unidade,
  pesoLiquido, pesoBruto, volumes, itensPorCaixa,
  gtin, tipoProducao, marca, precoCompra,
  largura, altura, profundidade,
  unidadeMedida, fkFornecedor, fkCategoria, fkProduto

Ao fechar:
  reabre menu_principal.py com --skip-entrada (para não abrir tela de entrada).
"""

from __future__ import annotations

import json
import os
import sys
import subprocess
import tkinter as tk
from tkinter import ttk, messagebox
from dataclasses import dataclass
from decimal import Decimal, InvalidOperation
from typing import Optional, Any

import psycopg2


# ============================================================
# AJUSTES IMPORTANTES
# ============================================================

# Se o nome da tabela for outro, ajuste aqui:
INFO_TABLE = '"Ekenox"."infoProduto"'   # ex: '"Ekenox"."info_produto"'


# ============================================================
# PASTAS / BASE DIR
# ============================================================

def get_app_dir() -> str:
    if getattr(sys, "frozen", False):
        return os.path.dirname(sys.executable)
    return os.path.dirname(os.path.abspath(__file__))


APP_DIR = get_app_dir()

# Ajuste seu BASE_DIR conforme seu padrão
BASE_DIR = r"C:\Users\User\Desktop\Pyton\OrdemProducao"
os.makedirs(BASE_DIR, exist_ok=True)


# ============================================================
# LOG
# ============================================================

def _log_write(filename: str, msg: str) -> None:
    try:
        log_dir = os.path.join(BASE_DIR, "logs")
        os.makedirs(log_dir, exist_ok=True)
        log_path = os.path.join(log_dir, filename)
        with open(log_path, "a", encoding="utf-8") as f:
            f.write(msg + "\n")
    except Exception:
        pass


def log_info(msg: str) -> None:
    _log_write("tela_info_produto.log", msg)


# ============================================================
# ÍCONE
# ============================================================

def find_icon_path() -> Optional[str]:
    candidates = [
        os.path.join(BASE_DIR, "imagens", "favicon.ico"),
        os.path.join(BASE_DIR, "favicon.ico"),
        os.path.join(APP_DIR, "imagens", "favicon.ico"),
        os.path.join(APP_DIR, "favicon.ico"),
    ]
    for p in candidates:
        if os.path.isfile(p):
            return p
    return None


def apply_window_icon(win) -> None:
    try:
        ico = find_icon_path()
        if ico:
            try:
                win.iconbitmap(default=ico)
            except Exception:
                pass

        png_candidates = [
            os.path.join(BASE_DIR, "imagens", "favicon.png"),
            os.path.join(APP_DIR, "imagens", "favicon.png"),
        ]
        png = next((p for p in png_candidates if os.path.isfile(p)), None)
        if png:
            img = tk.PhotoImage(file=png)
            win.iconphoto(True, img)
            win._icon_img = img  # mantém referência
    except Exception:
        pass


# ============================================================
# CONFIG DO APP (BANCO)
# ============================================================

@dataclass
class AppConfig:
    db_host: str = "10.0.0.154"
    db_database: str = "postgresekenox"
    db_user: str = "postgresekenox"
    db_password: str = "Ekenox5426"
    db_port: int = 55432


def config_path() -> str:
    return os.path.join(BASE_DIR, "config_op.json")


def load_config() -> AppConfig:
    p = config_path()
    if not os.path.exists(p):
        return AppConfig()
    try:
        with open(p, "r", encoding="utf-8") as f:
            data = json.load(f)
        return AppConfig(**data)
    except Exception:
        return AppConfig()


def env_override(cfg: AppConfig) -> AppConfig:
    host = (os.getenv("DB_HOST") or "").strip() or cfg.db_host
    port_s = (os.getenv("DB_PORT") or "").strip()
    dbname = (os.getenv("DB_NAME") or os.getenv(
        "DB_DATABASE") or "").strip() or cfg.db_database
    user = (os.getenv("DB_USER") or "").strip() or cfg.db_user
    password = (os.getenv("DB_PASSWORD") or "").strip() or cfg.db_password

    try:
        port = int(port_s) if port_s else int(cfg.db_port)
    except ValueError:
        port = int(cfg.db_port)

    return AppConfig(
        db_host=host,
        db_port=port,
        db_database=dbname,
        db_user=user,
        db_password=password,
    )


# ============================================================
# DB
# ============================================================

class Database:
    def __init__(self, cfg: AppConfig) -> None:
        self.cfg = cfg
        self.conn = None
        self.cursor = None
        self.ultimo_erro: Optional[str] = None

    def conectar(self) -> bool:
        self.ultimo_erro = None
        try:
            self.conn = psycopg2.connect(
                host=self.cfg.db_host,
                database=self.cfg.db_database,
                user=self.cfg.db_user,
                password=self.cfg.db_password,
                port=int(self.cfg.db_port),
                connect_timeout=5,
            )
            self.cursor = self.conn.cursor()
            return True
        except Exception as e:
            self.ultimo_erro = f"{type(e).__name__}: {e}"
            return False

    def commit(self) -> None:
        if self.conn:
            self.conn.commit()

    def desconectar(self) -> None:
        try:
            if self.cursor:
                try:
                    self.cursor.close()
                except Exception:
                    pass
            if self.conn:
                try:
                    self.conn.close()
                except Exception:
                    pass
        finally:
            self.cursor = None
            self.conn = None


# ============================================================
# MENU PRINCIPAL (ao fechar)
# ============================================================

MENU_FILENAMES = [
    "menu_principal.py",
    "Menu_Principal.py",
    "MenuPrincipal.py",
    "menu.py",
    "menu_principal.exe",
    "Menu_Principal.exe",
    "MenuPrincipal.exe",
    "menu.exe",
]


def localizar_menu_principal() -> Optional[str]:
    pastas = [APP_DIR, BASE_DIR]
    for pasta in pastas:
        for nome in MENU_FILENAMES:
            p = os.path.join(pasta, nome)
            if os.path.isfile(p):
                return os.path.abspath(p)
    return None


def _python_gui_windows() -> str:
    py = sys.executable
    if os.name == "nt":
        base = os.path.basename(py).lower()
        if base == "python.exe":
            pyw = os.path.join(os.path.dirname(py), "pythonw.exe")
            if os.path.isfile(pyw):
                return pyw
    return py


def abrir_menu_principal_skip_entrada() -> None:
    menu_path = localizar_menu_principal()
    if not menu_path:
        log_info(
            f"MENU: não encontrado. APP_DIR={APP_DIR} BASE_DIR={BASE_DIR}")
        return

    try:
        cwd = os.path.dirname(menu_path) or APP_DIR
        if menu_path.lower().endswith(".exe"):
            if os.name == "nt":
                os.startfile(menu_path)  # type: ignore[attr-defined]
            else:
                subprocess.Popen([menu_path], cwd=cwd)
            return

        # .py
        py = _python_gui_windows() if os.name == "nt" else sys.executable
        cmd = [py, menu_path, "--skip-entrada"]

        popen_kwargs: dict[str, Any] = {"cwd": cwd}
        if os.name == "nt":
            popen_kwargs["creationflags"] = subprocess.CREATE_NEW_PROCESS_GROUP | subprocess.DETACHED_PROCESS
        else:
            popen_kwargs["start_new_session"] = True

        subprocess.Popen(cmd, **popen_kwargs)
        log_info(f"MENU: iniciado -> {cmd}")

    except Exception as e:
        log_info(f"MENU: erro ao abrir: {type(e).__name__}: {e}")


# ============================================================
# MODEL
# ============================================================

@dataclass
class InfoProduto:
    # 19 colunas (conforme imagem)
    estoqueMinimo: Optional[int]
    estoqueMaximo: Optional[int]
    estoqueLocalizacao: Optional[str]
    unidade: Optional[str]
    pesoLiquido: Decimal
    pesoBruto: Decimal
    volumes: Optional[int]
    itensPorCaixa: Optional[int]
    gtin: Optional[str]
    tipoProducao: Optional[str]
    marca: Optional[str]
    precoCompra: Decimal
    largura: Decimal
    altura: Decimal
    profundidade: Decimal
    unidadeMedida: Optional[str]
    fkFornecedor: Optional[int]
    fkCategoria: Optional[int]
    fkProduto: int

    # extra (não é coluna da tabela): nome do produto (se existir join)
    nomeProduto: Optional[str] = None


# ============================================================
# CONVERSÕES
# ============================================================

def _clean_text(v: Any) -> Optional[str]:
    if v is None:
        return None
    s = str(v).strip()
    return s if s != "" else None


def _to_int_or_none(v: Any, field_name: str) -> Optional[int]:
    s = "" if v is None else str(v).strip()
    if s == "":
        return None
    try:
        return int(s)
    except ValueError:
        raise ValueError(f"{field_name} deve ser inteiro (ou vazio).")


def _to_int_required(v: Any, field_name: str) -> int:
    s = "" if v is None else str(v).strip()
    if s == "":
        raise ValueError(f"{field_name} é obrigatório.")
    try:
        return int(s)
    except ValueError:
        raise ValueError(f"{field_name} deve ser inteiro.")


def _to_decimal(v: Any, field_name: str) -> Decimal:
    s = "" if v is None else str(v).strip()
    if s == "":
        return Decimal("0")

    # aceita 1.234,56 / 1234,56 / 1234.56
    if "," in s and "." in s:
        s = s.replace(".", "").replace(",", ".")
    else:
        s = s.replace(",", ".")

    try:
        return Decimal(s)
    except InvalidOperation:
        raise ValueError(f"{field_name} inválido: {v!r}")


# ============================================================
# REPOSITORY
# ============================================================

class InfoProdutoRepo:
    def __init__(self, db: Database) -> None:
        self.db = db

    def listar(self, termo: Optional[str] = None, limit: int = 300) -> list[InfoProduto]:
        """
        Busca por:
          - fkProduto (texto)
          - gtin
          - marca
        Faz join com produtos apenas para trazer nomeProduto (se existir).
        Se o join falhar (tabela diferente), ainda lista a info.
        """
        like = f"%{termo}%" if termo else None

        # tenta JOIN com produtos (melhora usabilidade)
        sql_join = f"""
            SELECT
                i."estoqueMinimo", i."estoqueMaximo", i."estoqueLocalizacao", i."unidade",
                i."pesoLiquido", i."pesoBruto", i."volumes", i."itensPorCaixa",
                i."gtin", i."tipoProducao", i."marca", i."precoCompra",
                i."largura", i."altura", i."profundidade",
                i."unidadeMedida", i."fkFornecedor", i."fkCategoria", i."fkProduto",
                p."nomeProduto"
            FROM {INFO_TABLE} AS i
            LEFT JOIN "Ekenox"."produtos" AS p
                ON p."produtoId" = i."fkProduto"
            WHERE (%s IS NULL)
               OR (CAST(i."fkProduto" AS TEXT) ILIKE %s)
               OR (COALESCE(i."gtin",'') ILIKE %s)
               OR (COALESCE(i."marca",'') ILIKE %s)
            ORDER BY i."fkProduto"
            LIMIT %s
        """

        sql_nojoin = f"""
            SELECT
                i."estoqueMinimo", i."estoqueMaximo", i."estoqueLocalizacao", i."unidade",
                i."pesoLiquido", i."pesoBruto", i."volumes", i."itensPorCaixa",
                i."gtin", i."tipoProducao", i."marca", i."precoCompra",
                i."largura", i."altura", i."profundidade",
                i."unidadeMedida", i."fkFornecedor", i."fkCategoria", i."fkProduto"
            FROM {INFO_TABLE} AS i
            WHERE (%s IS NULL)
               OR (CAST(i."fkProduto" AS TEXT) ILIKE %s)
               OR (COALESCE(i."gtin",'') ILIKE %s)
               OR (COALESCE(i."marca",'') ILIKE %s)
            ORDER BY i."fkProduto"
            LIMIT %s
        """

        params = (termo, like, like, like, limit)

        if not self.db.conectar():
            raise RuntimeError(f"Falha ao conectar: {self.db.ultimo_erro}")

        try:
            assert self.db.cursor is not None
            try:
                self.db.cursor.execute(sql_join, params)
                rows = self.db.cursor.fetchall()
                result: list[InfoProduto] = []
                for row in rows:
                    # row tem 20 itens (inclui nomeProduto)
                    info = InfoProduto(*row[:19], nomeProduto=row[19])
                    result.append(info)
                return result
            except Exception:
                # fallback sem join
                self.db.cursor.execute(sql_nojoin, params)
                rows = self.db.cursor.fetchall()
                return [InfoProduto(*row, nomeProduto=None) for row in rows]
        finally:
            self.db.desconectar()

    def exists(self, fkProduto: int) -> bool:
        sql = f'SELECT 1 FROM {INFO_TABLE} WHERE "fkProduto" = %s'
        if not self.db.conectar():
            raise RuntimeError(f"Falha ao conectar: {self.db.ultimo_erro}")
        try:
            assert self.db.cursor is not None
            self.db.cursor.execute(sql, (fkProduto,))
            return self.db.cursor.fetchone() is not None
        finally:
            self.db.desconectar()

    def inserir(self, i: InfoProduto) -> None:
        sql = f"""
            INSERT INTO {INFO_TABLE}
            ("estoqueMinimo","estoqueMaximo","estoqueLocalizacao","unidade",
             "pesoLiquido","pesoBruto","volumes","itensPorCaixa",
             "gtin","tipoProducao","marca","precoCompra",
             "largura","altura","profundidade",
             "unidadeMedida","fkFornecedor","fkCategoria","fkProduto")
            VALUES
            (%s,%s,%s,%s,
             %s,%s,%s,%s,
             %s,%s,%s,%s,
             %s,%s,%s,
             %s,%s,%s,%s)
        """
        params = (
            i.estoqueMinimo, i.estoqueMaximo, i.estoqueLocalizacao, i.unidade,
            i.pesoLiquido, i.pesoBruto, i.volumes, i.itensPorCaixa,
            i.gtin, i.tipoProducao, i.marca, i.precoCompra,
            i.largura, i.altura, i.profundidade,
            i.unidadeMedida, i.fkFornecedor, i.fkCategoria, i.fkProduto
        )

        if not self.db.conectar():
            raise RuntimeError(f"Falha ao conectar: {self.db.ultimo_erro}")
        try:
            assert self.db.cursor is not None
            self.db.cursor.execute(sql, params)
            self.db.commit()
        finally:
            self.db.desconectar()

    def atualizar(self, i: InfoProduto) -> None:
        sql = f"""
            UPDATE {INFO_TABLE}
               SET "estoqueMinimo" = %s,
                   "estoqueMaximo" = %s,
                   "estoqueLocalizacao" = %s,
                   "unidade" = %s,
                   "pesoLiquido" = %s,
                   "pesoBruto" = %s,
                   "volumes" = %s,
                   "itensPorCaixa" = %s,
                   "gtin" = %s,
                   "tipoProducao" = %s,
                   "marca" = %s,
                   "precoCompra" = %s,
                   "largura" = %s,
                   "altura" = %s,
                   "profundidade" = %s,
                   "unidadeMedida" = %s,
                   "fkFornecedor" = %s,
                   "fkCategoria" = %s
             WHERE "fkProduto" = %s
        """
        params = (
            i.estoqueMinimo, i.estoqueMaximo, i.estoqueLocalizacao, i.unidade,
            i.pesoLiquido, i.pesoBruto, i.volumes, i.itensPorCaixa,
            i.gtin, i.tipoProducao, i.marca, i.precoCompra,
            i.largura, i.altura, i.profundidade,
            i.unidadeMedida, i.fkFornecedor, i.fkCategoria, i.fkProduto
        )

        if not self.db.conectar():
            raise RuntimeError(f"Falha ao conectar: {self.db.ultimo_erro}")
        try:
            assert self.db.cursor is not None
            self.db.cursor.execute(sql, params)
            self.db.commit()
        finally:
            self.db.desconectar()

    def excluir(self, fkProduto: int) -> None:
        sql = f'DELETE FROM {INFO_TABLE} WHERE "fkProduto" = %s'
        if not self.db.conectar():
            raise RuntimeError(f"Falha ao conectar: {self.db.ultimo_erro}")
        try:
            assert self.db.cursor is not None
            self.db.cursor.execute(sql, (fkProduto,))
            self.db.commit()
        finally:
            self.db.desconectar()


# ============================================================
# SERVICE
# ============================================================

class InfoProdutoService:
    def __init__(self, repo: InfoProdutoRepo) -> None:
        self.repo = repo

    def listar(self, termo: Optional[str]) -> list[InfoProduto]:
        termo = (termo or "").strip() or None
        return self.repo.listar(termo=termo)

    def salvar_from_form(self, form: dict[str, Any]) -> str:
        fkProduto = _to_int_required(form.get("fkProduto"), "fkProduto")

        info = InfoProduto(
            estoqueMinimo=_to_int_or_none(
                form.get("estoqueMinimo"), "estoqueMinimo"),
            estoqueMaximo=_to_int_or_none(
                form.get("estoqueMaximo"), "estoqueMaximo"),
            estoqueLocalizacao=_clean_text(form.get("estoqueLocalizacao")),
            unidade=_clean_text(form.get("unidade")),
            pesoLiquido=_to_decimal(form.get("pesoLiquido"), "pesoLiquido"),
            pesoBruto=_to_decimal(form.get("pesoBruto"), "pesoBruto"),
            volumes=_to_int_or_none(form.get("volumes"), "volumes"),
            itensPorCaixa=_to_int_or_none(
                form.get("itensPorCaixa"), "itensPorCaixa"),
            gtin=_clean_text(form.get("gtin")),
            tipoProducao=_clean_text(form.get("tipoProducao")),
            marca=_clean_text(form.get("marca")),
            precoCompra=_to_decimal(form.get("precoCompra"), "precoCompra"),
            largura=_to_decimal(form.get("largura"), "largura"),
            altura=_to_decimal(form.get("altura"), "altura"),
            profundidade=_to_decimal(form.get("profundidade"), "profundidade"),
            unidadeMedida=_clean_text(form.get("unidadeMedida")),
            fkFornecedor=_to_int_or_none(
                form.get("fkFornecedor"), "fkFornecedor"),
            fkCategoria=_to_int_or_none(
                form.get("fkCategoria"), "fkCategoria"),
            fkProduto=fkProduto,
        )

        # regras básicas (ajuste se quiser)
        if info.estoqueMinimo is not None and info.estoqueMinimo < 0:
            raise ValueError("estoqueMinimo não pode ser negativo.")
        if info.estoqueMaximo is not None and info.estoqueMaximo < 0:
            raise ValueError("estoqueMaximo não pode ser negativo.")

        if self.repo.exists(fkProduto):
            self.repo.atualizar(info)
            return "atualizado"
        else:
            self.repo.inserir(info)
            return "inserido"

    def excluir(self, fkProduto: int) -> None:
        self.repo.excluir(fkProduto)


# ============================================================
# UI
# ============================================================

DEFAULT_GEOMETRY = "1200x720"
APP_TITLE = "Tela de InfoProduto"

CAMPOS = [
    ("fkProduto", "Produto (fkProduto)"),
    ("fkCategoria", "Categoria (fkCategoria)"),
    ("fkFornecedor", "Fornecedor (fkFornecedor)"),

    ("gtin", "GTIN"),
    ("marca", "Marca"),
    ("tipoProducao", "Tipo Produção"),

    ("estoqueMinimo", "Estoque Mínimo"),
    ("estoqueMaximo", "Estoque Máximo"),
    ("estoqueLocalizacao", "Localização"),
    ("unidade", "Unidade"),
    ("unidadeMedida", "Unidade Medida"),

    ("itensPorCaixa", "Itens por Caixa"),
    ("volumes", "Volumes"),

    ("precoCompra", "Preço Compra"),
    ("pesoLiquido", "Peso Líquido"),
    ("pesoBruto", "Peso Bruto"),

    ("largura", "Largura"),
    ("altura", "Altura"),
    ("profundidade", "Profundidade"),
]


TREE_COLS = [
    "fkProduto", "nomeProduto",
    "gtin", "marca", "tipoProducao",
    "estoqueMinimo", "estoqueMaximo", "estoqueLocalizacao",
    "unidade", "unidadeMedida",
    "itensPorCaixa", "volumes",
    "precoCompra", "pesoLiquido", "pesoBruto",
    "largura", "altura", "profundidade",
    "fkFornecedor", "fkCategoria",
]


class TelaInfoProduto(ttk.Frame):
    def __init__(self, master: tk.Misc, service: InfoProdutoService):
        super().__init__(master)
        self.service = service

        self.vars: dict[str, tk.StringVar] = {
            k: tk.StringVar() for k, _ in CAMPOS}
        self.var_filtro = tk.StringVar()

        self._build_ui()
        self.atualizar_lista()

    def _build_ui(self) -> None:
        self.columnconfigure(0, weight=1)
        self.rowconfigure(2, weight=1)

        top = ttk.Frame(self)
        top.grid(row=0, column=0, sticky="ew", padx=10, pady=(10, 6))
        top.columnconfigure(1, weight=1)

        ttk.Label(
            top, text="Buscar (fkProduto / GTIN / Marca):").grid(row=0, column=0, sticky="w")
        ent = ttk.Entry(top, textvariable=self.var_filtro)
        ent.grid(row=0, column=1, sticky="ew", padx=(6, 6))
        ent.bind("<Return>", lambda e: self.atualizar_lista())

        ttk.Button(top, text="Atualizar", command=self.atualizar_lista).grid(
            row=0, column=2, padx=(0, 6))
        ttk.Button(top, text="Novo", command=self.novo).grid(
            row=0, column=3, padx=(0, 6))
        ttk.Button(top, text="Salvar", command=self.salvar).grid(
            row=0, column=4, padx=(0, 6))
        ttk.Button(top, text="Excluir", command=self.excluir).grid(
            row=0, column=5, padx=(0, 6))
        ttk.Button(top, text="Limpar", command=self.limpar_form).grid(
            row=0, column=6)

        form = ttk.LabelFrame(self, text="InfoProduto")
        form.grid(row=1, column=0, sticky="ew", padx=10, pady=(0, 8))

        for c in range(6):
            form.columnconfigure(c, weight=1)

        # Layout em linhas (3 campos por linha)
        self._add_field(form, 0, 0, "fkProduto", width=12)
        self._add_field(form, 0, 2, "fkCategoria", width=12)
        self._add_field(form, 0, 4, "fkFornecedor", width=12)

        self._add_field(form, 1, 0, "gtin", width=18)
        self._add_field(form, 1, 2, "marca", width=18)
        self._add_field(form, 1, 4, "tipoProducao", width=18)

        self._add_field(form, 2, 0, "estoqueMinimo", width=12)
        self._add_field(form, 2, 2, "estoqueMaximo", width=12)
        self._add_field(form, 2, 4, "estoqueLocalizacao", width=22)

        self._add_field(form, 3, 0, "unidade", width=12)
        self._add_field(form, 3, 2, "unidadeMedida", width=14)
        self._add_field(form, 3, 4, "itensPorCaixa", width=12)

        self._add_field(form, 4, 0, "volumes", width=12)
        self._add_field(form, 4, 2, "precoCompra", width=12)
        self._add_field(form, 4, 4, "pesoLiquido", width=12)

        self._add_field(form, 5, 0, "pesoBruto", width=12)
        self._add_field(form, 5, 2, "largura", width=12)
        self._add_field(form, 5, 4, "altura", width=12)

        self._add_field(form, 6, 0, "profundidade", width=12, colspan=2)

        # Lista
        lst = ttk.Frame(self)
        lst.grid(row=2, column=0, sticky="nsew", padx=10, pady=(0, 10))
        lst.rowconfigure(0, weight=1)
        lst.columnconfigure(0, weight=1)

        self.tree = ttk.Treeview(
            lst, columns=TREE_COLS, show="headings", selectmode="browse")
        self.tree.grid(row=0, column=0, sticky="nsew")

        vsb = ttk.Scrollbar(lst, orient="vertical", command=self.tree.yview)
        hsb = ttk.Scrollbar(lst, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        vsb.grid(row=0, column=1, sticky="ns")
        hsb.grid(row=1, column=0, sticky="ew")

        # headings
        headings = {
            "fkProduto": "fkProduto",
            "nomeProduto": "Nome Produto",
            "gtin": "GTIN",
            "marca": "Marca",
            "tipoProducao": "Tipo",
            "estoqueMinimo": "Min",
            "estoqueMaximo": "Max",
            "estoqueLocalizacao": "Local",
            "unidade": "Unidade",
            "unidadeMedida": "Unid Med",
            "itensPorCaixa": "Itens/Cx",
            "volumes": "Vol",
            "precoCompra": "Preço",
            "pesoLiquido": "Peso L",
            "pesoBruto": "Peso B",
            "largura": "Larg",
            "altura": "Alt",
            "profundidade": "Prof",
            "fkFornecedor": "Fornecedor",
            "fkCategoria": "Categoria",
        }

        for col in TREE_COLS:
            self.tree.heading(col, text=headings.get(col, col))

        # larguras (ajuste fino se quiser)
        self.tree.column("fkProduto", width=80, anchor="e", stretch=False)
        self.tree.column("nomeProduto", width=220, anchor="w", stretch=True)
        self.tree.column("gtin", width=140, anchor="w", stretch=False)
        self.tree.column("marca", width=120, anchor="w", stretch=False)
        self.tree.column("tipoProducao", width=90, anchor="w", stretch=False)

        for col in TREE_COLS:
            if col in ("fkProduto", "nomeProduto", "gtin", "marca", "tipoProducao"):
                continue
            self.tree.column(col, width=90, anchor="e", stretch=False)

        self.tree.bind("<<TreeviewSelect>>", self.on_select)

    def _add_field(
        self,
        parent: ttk.Frame,
        row: int,
        col: int,
        key: str,
        readonly: bool = False,
        colspan: int = 2,
        width: int | None = None,
    ) -> None:
        label = dict(CAMPOS)[key]
        ttk.Label(parent, text=f"{label}:").grid(
            row=row, column=col, sticky="w", padx=(10, 6), pady=6)

        state = "readonly" if readonly else "normal"
        ent = ttk.Entry(parent, textvariable=self.vars[key], state=state)
        if width is not None:
            ent.configure(width=width)

        ent.grid(row=row, column=col + 1, sticky="ew",
                 padx=(0, 10), pady=6, columnspan=colspan - 1)

    # -------- ações --------

    def atualizar_lista(self) -> None:
        termo = self.var_filtro.get().strip() or None

        for item in self.tree.get_children():
            self.tree.delete(item)

        try:
            itens = self.service.listar(termo)
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao listar InfoProduto:\n{e}")
            return

        for it in itens:
            values = [
                it.fkProduto,
                it.nomeProduto or "",
                it.gtin or "",
                it.marca or "",
                it.tipoProducao or "",
                "" if it.estoqueMinimo is None else it.estoqueMinimo,
                "" if it.estoqueMaximo is None else it.estoqueMaximo,
                it.estoqueLocalizacao or "",
                it.unidade or "",
                it.unidadeMedida or "",
                "" if it.itensPorCaixa is None else it.itensPorCaixa,
                "" if it.volumes is None else it.volumes,
                str(it.precoCompra),
                str(it.pesoLiquido),
                str(it.pesoBruto),
                str(it.largura),
                str(it.altura),
                str(it.profundidade),
                "" if it.fkFornecedor is None else it.fkFornecedor,
                "" if it.fkCategoria is None else it.fkCategoria,
            ]
            self.tree.insert("", "end", values=values)

    def on_select(self, _event=None) -> None:
        sel = self.tree.selection()
        if not sel:
            return
        vals = self.tree.item(sel[0], "values")

        # mapeia de volta para o form (sem nomeProduto)
        mapping = {
            "fkProduto": vals[0],
            "gtin": vals[2],
            "marca": vals[3],
            "tipoProducao": vals[4],
            "estoqueMinimo": vals[5],
            "estoqueMaximo": vals[6],
            "estoqueLocalizacao": vals[7],
            "unidade": vals[8],
            "unidadeMedida": vals[9],
            "itensPorCaixa": vals[10],
            "volumes": vals[11],
            "precoCompra": vals[12],
            "pesoLiquido": vals[13],
            "pesoBruto": vals[14],
            "largura": vals[15],
            "altura": vals[16],
            "profundidade": vals[17],
            "fkFornecedor": vals[18],
            "fkCategoria": vals[19],
        }

        for k, _ in CAMPOS:
            v = mapping.get(k, "")
            self.vars[k].set("" if v in (None, "None") else str(v))

    def novo(self) -> None:
        self.limpar_form()
        # defaults numéricos úteis
        self.vars["precoCompra"].set("0")
        self.vars["pesoLiquido"].set("0")
        self.vars["pesoBruto"].set("0")
        self.vars["largura"].set("0")
        self.vars["altura"].set("0")
        self.vars["profundidade"].set("0")

    def limpar_form(self) -> None:
        for k in self.vars:
            self.vars[k].set("")
        self.tree.selection_remove(self.tree.selection())

    def salvar(self) -> None:
        form = {k: self.vars[k].get() for k, _ in CAMPOS}
        try:
            status = self.service.salvar_from_form(form)
        except Exception as e:
            messagebox.showerror("Validação/Erro", str(e))
            return

        messagebox.showinfo("OK", f"InfoProduto {status} com sucesso.")
        self.atualizar_lista()

    def excluir(self) -> None:
        fk_str = self.vars["fkProduto"].get().strip()
        if not fk_str:
            messagebox.showwarning(
                "Atenção", "Informe/Selecione um fkProduto para excluir.")
            return

        if not messagebox.askyesno("Confirmar", f"Excluir InfoProduto do Produto {fk_str}?"):
            return

        try:
            self.service.excluir(int(fk_str))
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao excluir:\n{e}")
            return

        messagebox.showinfo("OK", "InfoProduto excluído.")
        self.limpar_form()
        self.atualizar_lista()


# ============================================================
# STARTUP
# ============================================================

def test_connection_or_die(cfg: AppConfig) -> None:
    try:
        conn = psycopg2.connect(
            host=cfg.db_host,
            database=cfg.db_database,
            user=cfg.db_user,
            password=cfg.db_password,
            port=int(cfg.db_port),
            connect_timeout=5,
        )
        cur = conn.cursor()
        cur.execute("SELECT 1")
        cur.fetchone()
        cur.close()
        conn.close()
    except Exception as e:
        raise RuntimeError(f"{type(e).__name__}: {e}")


def main() -> None:
    cfg = env_override(load_config())

    root = tk.Tk()
    root.title(APP_TITLE)
    root.geometry(DEFAULT_GEOMETRY)
    apply_window_icon(root)

    try:
        style = ttk.Style()
        if "clam" in style.theme_names():
            style.theme_use("clam")
    except Exception:
        pass

    try:
        test_connection_or_die(cfg)
    except Exception as e:
        messagebox.showerror(
            "Erro de conexão",
            "Não foi possível conectar ao banco.\n\n"
            f"Host: {cfg.db_host}\n"
            f"Porta: {cfg.db_port}\n"
            f"Banco: {cfg.db_database}\n"
            f"Usuário: {cfg.db_user}\n\n"
            f"Erro:\n{e}"
        )
        root.destroy()
        return

    db = Database(cfg)
    repo = InfoProdutoRepo(db)
    service = InfoProdutoService(repo)

    tela = TelaInfoProduto(root, service)
    tela.pack(fill="both", expand=True)

    closing = {"done": False}

    def open_menu_then_close():
        if closing["done"]:
            return
        closing["done"] = True
        try:
            abrir_menu_principal_skip_entrada()
        finally:
            try:
                root.destroy()
            except Exception:
                pass

    def on_close():
        try:
            root.withdraw()
            root.update_idletasks()
        except Exception:
            pass
        root.after(50, open_menu_then_close)

    root.protocol("WM_DELETE_WINDOW", on_close)
    root.mainloop()


if __name__ == "__main__":
    main()
